
## 代理模式

* 抽象角色： 真实对象和代理对象的共同接口。
* 代理角色： 代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装
* 真实角色： 代理角色所代表的真实对象，是我们最终要引用的对象
* 根据代理类的生成时间不同可以将代理分为静态代理和动态代理两种。
###静态代理
### 由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了
### 静态代理的优缺点
* 业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点
####缺点：
* 代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了
* 如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度
###动态代理的概念
* 动态代理类的源码是程序在运行期间由JVM根据反射等机制动态生成的，所以不存在代理类的字节码文件。代理角色和真实角色的联系在程序运行时确定
* 动态代理技术在整个java技术中是非常重要的，他是学习java框架的基础，不会动态代理技术，在学习spring这些框架时学不明白
* 动态代理技术就是用来产生一个对象的代理对象的。
* 举一个现实生活中的例子：歌星或者明星都有一个自己的经纪人，这个经纪人就是他们的代理人，当我们需要找明星表演时，不能直接找到该明星，只能是找明星的代理人。比如刘德华在现实生活中非常有名，会唱歌，会跳舞，会拍戏，刘德华在没有出名之前，我们可以直接找他唱歌，跳舞，拍戏，刘德华出名之后，他干的第一件事就是找一个经纪人，这个经纪人就是刘德华的代理人(代理)，当我们需要找刘德华表演时，不能直接找到刘德华了(刘德华说，你找我代理人商谈具体事宜吧!)，只能是找刘德华的代理人，因此刘德华这个代理人存在的价值就是拦截我们对刘德华的直接访问！
  　　这个现实中的例子和我们在开发中是一样的，我们在开发中之所以要产生一个对象的代理对象，主要用于拦截对真实业务对象的访问。那么代理对象应该具有什么方法呢？代理对象应该具有和目标对象相同的方法
* 所以在这里明确代理对象的两个概念：
　　　　1、代理对象存在的价值主要用于拦截对真实业务对象的访问。
　　　　2、代理对象应该具有和目标对象(真实业务对象)相同的方法。刘德华(真实业务对象)会唱歌，会跳舞，会拍戏，我们现在不能直接找他唱歌，跳舞，拍戏了，只能找他的代理人(代理对象)唱歌，跳舞，拍戏，一个人要想成为刘德华的代理人，那么他必须具有和刘德华一样的行为(会唱歌，会跳舞，会拍戏)，刘德华有什么方法，他(代理人)就要有什么方法，我们找刘德华的代理人唱歌，跳舞，拍戏，但是代理人不是真的懂得唱歌，跳舞，拍戏的，真正懂得唱歌，跳舞，拍戏的是刘德华，在现实中的例子就是我们要找刘德华唱歌，跳舞，拍戏，那么只能先找他的经纪人，交钱给他的经纪人，然后经纪人再让刘德华去唱歌，跳舞，拍戏。


## java中的代理

### 1. "java.lang.reflect.Proxy"类介绍
* 现在要生成某一个对象的代理对象，这个代理对象通常也要编写一个类来生成，所以首先要编写用于生成代理对象的类。在java中如何用程序去生成一个对象的代理对象呢，java在JDK1.5之后提供了一个"java.lang.reflect.Proxy"类，通过"Proxy"类提供的一个newProxyInstance方法用来创建一个对象的代理对象，
如下所示：
```
static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) 
```
* newProxyInstance方法用来返回一个代理对象，这个方法总共有3个参数：
* ClassLoader loader用来指明生成代理对象使用哪个类装载器
* Class<?>[] interfaces用来指明生成哪个对象的代理对象，通过接口指定
* InvocationHandler h用来指明产生的这个代理对象要做什么事情
* 所以我们只需要调用newProxyInstance方法就可以得到某一个对象的代理对象了
### 2. 编写生成代理对象的类
在java中规定，要想产生一个对象的代理对象，那么这个对象必须要有一个接口，所以我们第一步就是设计这个对象的接口，在接口中定义这个对象所具有的行为(方法)
