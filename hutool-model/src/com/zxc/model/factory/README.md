
## 工厂模式
主要是为创建对象提供接口，将创建对象的过程隔离起来，实现了创建者与调用者的分离，提高了程序的灵活性。 
###核心本质：
* 实例化对象，用工厂方法代替new操作
* 将选择实现类、创建对象统一管理和控制，从而将调用者跟我们实现类解耦
###工厂模式分类：
* 简单工厂模式（Simple Factory）
* 工厂方法模式(Factory Method)
* 抽象工厂模式(Abstract Factory)
###一、简单工厂模式
又称为静态工厂方法模式用来生产同一等级结构中的任意产品，通过 建立一个工厂（一个函数或一个类方法）来制造新的对象

请看simpleFactory例子，这个工厂模式不太好，因为每增加一种新的车型，都要在工厂中增加相应的创造方法，这违背了开闭原则。可想而知对于新产品的加入，工厂类是很被动的。对于这样的工厂类，我们称它为全能类或者上帝类。 
于是工厂方法模式出现了。 工厂类定义成了接口,而每新增的车种类型,就增加该车种类型对应工厂类的实现,这样工厂的设计就可以扩展了,而不必去修改原来的代码

###二、工厂方法模式：
工厂方法模式是简单工厂模式的进一步抽象化和推广，工厂方法模式里不再只由一个工厂类决定那一个产品类应当被实例化,这个决定被交给抽象工厂的子类去做
####模式组成结构：
* 抽象产品： 它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现
* 具体产品： 工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现
* 抽象工厂： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。
* 具体工厂： 它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。

工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的“上帝类”。正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活 起来——当有新的产品产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有的代 码。可以看出工厂角色的结构也是符合开闭原则的
###三、简单工厂模式VS工厂方法模式
* 1)结构复杂度：简单工厂模式优胜。 
* 2）代码复杂度：简单工厂模式占优。 
* 3）管理难度： 工厂方法模式的核心是一个抽象工厂类,而不像简单工厂模式, 把核心放在一个实类上。可拓展性更好，易于管理

总结：根据设计理论建议用工厂方法模式，但是实际上，我们一般都是使用简单工厂模式！
## 抽象工厂模式
在抽象工厂模式中，抽象产品 (AbstractProduct) 可能是一个或多个，从而构成一个或多个产品族(Product Family)。如构成一辆车需要有发动机，座椅，轮胎等配件，而每个配件又有多种（如发动机有A，B不同型号），
那么该抽象产品构成一个产品族。 
　　当每个抽象产品都有多于一个的具体子类的时候（发动机有型号A和B两种，座椅也有型号A和B两种），工厂角色怎么知道实例化哪一个子类呢？比如每个抽象产品角色都有两个具体产品
（产品轮胎有两个具体产品轮胎A和轮胎B）。抽象工厂模式提供两个具体工厂角色（A型汽车系列工厂和B型系列工厂），
分别对应于这两个具体产品角色，每一个具体工厂角色只负责某一个产品角色的实例化。每一个具体工厂类只负责创建抽象产品的某一个具体子类的实例。
#### 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。它针对的是有多个产品的等级结构
